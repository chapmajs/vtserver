head	2.3;
access;
symbols;
locks
	wkt:2.3; strict;
comment	@ * @;


2.3
date	2001.03.23.00.02.49;	author wkt;	state Exp;
branches
	2.3.1.1;
next	2.2;

2.2
date	2001.03.02.04.55.22;	author mhol;	state Exp;
branches;
next	2.1;

2.1
date	2001.03.02.04.40.31;	author mhol;	state Exp;
branches;
next	2.0;

2.0
date	2001.01.30.03.28.14;	author mhol;	state Exp;
branches;
next	1.1;

1.1
date	2001.01.24.02.22.10;	author mhol;	state Exp;
branches;
next	;

2.3.1.1
date	2001.03.24.07.01.48;	author wkt;	state Exp;
branches;
next	2.3.1.2;

2.3.1.2
date	2001.03.24.07.29.27;	author wkt;	state Exp;
branches;
next	2.3.1.3;

2.3.1.3
date	2001.03.25.01.21.27;	author wkt;	state Exp;
branches;
next	2.3.1.4;

2.3.1.4
date	2001.03.25.02.11.13;	author wkt;	state Exp;
branches;
next	2.3.1.5;

2.3.1.5
date	2001.04.04.02.57.28;	author wkt;	state Exp;
branches;
next	;


desc
@@


2.3
log
@change to console mode to start
@
text
@/*
 * Virtual tape driver - copyright 1998 Warren Toomey	wkt@@cs.adfa.edu.au
 *
 * $Revision: 2.2 $
 * $Date: 2001/03/02 04:55:22 $
 *
 *
 * This program sits on a serial line, receives `tape' commands from a
 * PDP-11, and returns the results of those command to the other machine.
 * It was designed to allow 7th Edition UNIX to be installed on to a
 * machine without a tape drive.
 *
 * Much of the functionality of the tape protocol has been designed but
 * not yet implemented.
 *
 * Commands look like the following:
 *
 *	  +----+----+-----+------+----+----+---+----+
 *	  | 31 | 42 | cmd | rec# | blk|num | ck|sum |
 *	  +----+----+-----+------+----+----+---+----+
 *
 * Each box is an octet. The block number is a 16-bit value, with the
 * low-order octet first. Any data that is transmitted (in either direction)
 * comes as 512 octets between the block number and the checksum. The
 * checksum is a bitwise-XOR of octet pairs, excluding the checksum itself.
 * I.e checksum octet 1 holds 31 XOR cmd XOR blklo [ XOR odd data octets ], and
 * checksum octet 2 holds 42 XOR rec# XOR blkhi [ XOR even data octets ].
 *
 * A write command from the client has 512 octets of data. Similarly, a read
 * command from the server to the client has 512 octets of data. 
 *
 *
 * The Protocol
 * ------------
 *
 * The protocol is stateless. Commands are read, zeroread, quickread, write,
 * open and close.
 *
 * The record number holds the fictitious tape record which is requested.
 * The server keeps one disk file per record. The block number holds the
 * 512-octet block number within the record.
 *
 * Assumptions: a read on a record without a previous open implies the open.
 * A command on a new record will close any previously opened record.
 * There is only one outstanding client request at any time.
 *
 * The client sends a command to the server. The server returns the command,
 * possibly with 512 octets of data, to the client. The top four bits of the
 * command octet hold the return error value. All bits off indicates no error.
 * If an error occurred, including EOF, no data octets are returned on a read
 * command.
 *
 * If the client receives a garbled return command, it will resend the command.
 * Therefore, the server must cope with this.
 *
 * The exception command to all of this is the QUICK read command. Here,
 * the server responds with one octet followed by 512 data octets. If the
 * octet is zero, data will be sent. Otherwise, the octet contains an
 * error value in the top four bits (including EOF), and no data is sent.
 * There are no command replies or checksums. This makes it useful only
 * to load one record by hand at bootstrap.

 * If the client requests a ZEROREAD, and if the server detects that the
 * block requested is all zeroes, then the returned message has cmd=ZEROREAD
 * and _no_ data octets. However, if any octet in the block non-zero, then
 * the server sends back a cmd=READ message with the 512-octets of data.
 *
 */

#include <sys/types.h>
#include <stdio.h>
#include <fcntl.h>
#include <termios.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
char *strerror(int errno);

/* Commands sent in both directions */
struct vtcmd {
  unsigned char hdr1;		/* Header, 31 followed by 42 (decimal) */
  unsigned char hdr2;
  unsigned char cmd;		/* Command, one of VTC_XXX below */
  				/* Error comes back in top 4 bits */
  unsigned char record;		/* Record we're accessing */
  unsigned char blklo;		/* Block number, in lo/hi format */
  unsigned char blkhi;
  unsigned char sum0;		/* 16-bit checksum */
  unsigned char sum1;		/* 16-bit checksum */
};

/* Header octets */
#define VT_HDR1		31
#define VT_HDR2		42

/* Commands available */
#define VTC_QUICK	0	/* Quick read, no cksum sent */
#define VTC_OPEN	1	/* Open the requested record */
#define VTC_CLOSE	2	/* Close the requested record */
#define VTC_READ	3	/* Read requested block from record */
#define VTC_WRITE	4	/* Write requested block from record */
#define VTC_ZEROREAD	6	/* Zero read, return no data if all zeroes */

/* Errors returned */
#define VTE_NOREC	1	/* No such record available */
#define VTE_OPEN	2	/* Can't open requested block */
#define VTE_CLOSE	3	/* Can't close requested block */
#define VTE_READ	4	/* Can't read requested block */
#define VTE_WRITE	5	/* Can't write requested block */
#define VTE_NOCMD	6	/* No such command */
#define VTE_EOF		7	/* End of file: no blocks left to read */

#define BLKSIZE		512

/* Static things */
extern int errno;		/* Error from system calls etc. */
struct vtcmd vtcmd;		/* Command from client */
struct vtcmd vtreply;		/* Reply to client */
char inbuf[BLKSIZE];		/* Input buffer */
char *port = NULL;		/* Device for serial port */
int portfd;			/* File descriptor for the port */
int ttyfd=0;			/* File descriptor for the console */
int recfd = -1;			/* File descriptor for the in-use record */
int lastrec = -2;		/* Last record used */
char *recname[256];		/* Up to 256 records on the tape */
struct termios oldterm;		/* Original terminal settings */


/* Get a command from the client.
 * If a command is received, returns 1,
 * otherwise return 0.
 */
int get_command(struct vtcmd *v)
{
  int i;
  unsigned char sum0, sum1;

  /* Get a valid command from the client */
  read(portfd, &v->hdr1, 1);
  if (v->hdr1 != VT_HDR1) { write(1,&v->hdr1, 1); return(0); }
  read(portfd, &v->hdr2, 1);
  if (v->hdr2 != VT_HDR2) { write(1,&v->hdr2, 1); return(0); }

  read(portfd, &v->cmd, 1); read(portfd, &v->record, 1);
  read(portfd, &v->blklo, 1); read(portfd, &v->blkhi, 1);

  /* Calc. the cksum to date */
  sum0 = VT_HDR1 ^ v->cmd ^ v->blklo;
  sum1 = VT_HDR2 ^ v->record ^ v->blkhi;

  /* All done if a quick read */
  if (v->cmd == VTC_QUICK) return(1);

  /* Retrieve the block if a WRITE cmd */
  if (v->cmd == VTC_WRITE) {
    for (i = 0; i < BLKSIZE; i++) {
      read(portfd, &inbuf[i], 1); sum0 ^= inbuf[i]; i++;
      read(portfd, &inbuf[i], 1); sum1 ^= inbuf[i];
    }
  }

  /* Get the checksum */
  read(portfd, &(v->sum0), 1);
  read(portfd, &(v->sum1), 1);

  /* Try again on a bad checksum */
  if ((sum0 != v->sum0) || (sum1 != v->sum1))
    { fputc('e',stderr); return(0); }

  return(1);
}


/* Reply has been mostly initialised by do_command */
void send_reply()
{
  int i;

  if ((vtcmd.cmd)==VTC_QUICK) {     /* Only send buffer on a quick read */
    write(portfd, &vtreply.cmd, 1);
    if (vtreply.cmd!=VTC_QUICK) return;	/* Must have been an error */
    for (i=0; i< BLKSIZE; i++) write(portfd, &inbuf[i], 1);
    return;
  }

  /* Calculate the checksum */
  vtreply.sum0 = VT_HDR1 ^ vtreply.cmd ^ vtreply.blklo;
  vtreply.sum1 = VT_HDR2 ^ vtreply.record ^ vtreply.blkhi;

			/* Data only on a read with no errors */
  if (vtreply.cmd == VTC_READ) {
    for (i = 0; i < BLKSIZE; i++) {
      vtreply.sum0 ^= inbuf[i]; i++;
      vtreply.sum1 ^= inbuf[i];
    }
  }
  /* Transmit the reply */
  write(portfd, &vtreply.hdr1, 1);
  write(portfd, &vtreply.hdr2, 1);
  write(portfd, &vtreply.cmd, 1);
  write(portfd, &vtreply.record, 1);
  write(portfd, &vtreply.blklo, 1);
  write(portfd, &vtreply.blkhi, 1);

  if (vtreply.cmd == VTC_READ) {
    for (i = 0; i < BLKSIZE; i++) write(portfd, &inbuf[i], 1);
  }
  write(portfd, &vtreply.sum0, 1);
  write(portfd, &vtreply.sum1, 1);
}


#define seterror(x)	vtreply.cmd |= (x<<4);

/* Actually do the command sent to us */
void do_command()
{
  int record, block, i, offset;

  /* First, copy the command to the reply */
  memcpy(&vtreply, &vtcmd, sizeof(vtcmd));

  record = vtcmd.record; block = (vtcmd.blkhi << 8) + vtcmd.blklo;
  offset = block * BLKSIZE;

  /* Open the record if not already open */
  if (record != lastrec) {
    if (recname[record] == NULL) {
	fprintf(stderr,"No such tape record %d\r\n",record);
	seterror(VTE_NOREC); return;
    }

    i = open(recname[record], O_RDWR);
    if (i == -1) {
      fprintf(stderr,"Cannot open %s: %s\r\n",recname[record], strerror(errno));
      seterror(VTE_NOREC); return;
    }

    if (record != lastrec) close(recfd);
    recfd = i; lastrec = record;
    fprintf(stderr,"\nOpened %s\r\n ", recname[record]);
  }

  switch (vtcmd.cmd) {
    case VTC_OPEN:  break;
    case VTC_CLOSE: close(recfd); lastrec = -1; break;

    case VTC_QUICK: vtreply.cmd=0;	/* No errors yet */
    case VTC_ZEROREAD: 
    case VTC_READ:  
		    i= lseek(recfd, offset, SEEK_SET);
      		    if (i==-1)
      		      { fprintf(stderr," EOF\r\n"); seterror(VTE_EOF); return; }
   		    i = read(recfd, &inbuf, BLKSIZE);
      		    if (i == 0)
      		      { fprintf(stderr," EOF\r\n"); seterror(VTE_EOF); return; }
      		    if (i == -1) { seterror(VTE_READ); return; }

				/* Determine if the entire block is zero */
		    if (vtcmd.cmd==VTC_ZEROREAD) {
		      for (i=0;i<BLKSIZE;i++) if (inbuf[i]!=0) break;
		      if (i==BLKSIZE) vtreply.cmd=VTC_ZEROREAD;
		      else vtreply.cmd=VTC_READ;
		    }

		    if (offset && (offset % 102400) == 0)
			fprintf(stderr,"\r\n%dK sent\r\n", offset/1024);
		    fputc('r',stderr);
      		    break;

    case VTC_WRITE: i= lseek(recfd, offset, SEEK_SET);
      		    if (i==-1)
      		      { fprintf(stderr," seek error\r\n");
			seterror(VTE_WRITE); return;
		      }
		    i = write(recfd, &inbuf, BLKSIZE);
      		    if (i < 1) { seterror(VTE_WRITE); return; }
		    if (offset && (offset % 102400) == 0)
			fprintf(stderr,"\r\n%dK received\r\n", offset/1024);
		    fputc('r',stderr);
		    fputc('w',stderr);
      	 	    break;

    default:	    fputc('?',stderr);
   		    seterror(VTE_NOCMD);
  }
  fflush(stderr);
}

/* The configuration file is .vtrc. The first line holds the name
 * of the serial device. The following lines hold the filenames which
 * are the successive tape records. Lines starting with a hash are ignored.
 * Files are not opened unless they are referenced by a client's command.
 */
void read_config()
{
  FILE *in;
  char *c;
  int i, cnt = 0, donesystem=0;

  in = fopen(".vtrc", "r");
  if (in == NULL) {
    fprintf(stderr, "Error opening .vtrc config file: %s\n", strerror(errno));
    exit(1);
  }
  while (cnt != 256) {
    if (feof(in)) break;
    c = fgets(inbuf, BLKSIZE - 2, in);
    if (feof(in)) break;

    if (c == NULL) {
      fprintf(stderr, "Error reading .vtrc config file: %s\n", strerror(errno));
      exit(1);
    }
    if (inbuf[0] == '#') continue;

    inbuf[strlen(inbuf) - 1] = '\0';	/* Remove training newline */

    if (donesystem == 0) {
	fprintf(stderr,"Running command %s\n\n",inbuf);
	system(inbuf); donesystem=1; continue;
    }

    if (port == NULL) {
      port = (char *) malloc(strlen(inbuf) + 2);
      strcpy(port, inbuf); continue;
    }

    recname[cnt] = (char *) malloc(strlen(inbuf) + 2);
    strcpy(recname[cnt], inbuf); cnt++;
  }
  fprintf(stderr,"Tape records are:\n");
  for (i=0; i<cnt; i++) fprintf(stderr,"  %2d %s\n", i, recname[i]);
  fprintf(stderr,"\n");

  fclose(in);
}

/* Use POSIX terminal commands to
 * set the serial line to raw mode.
 */
void setraw(int fd, char *portname, int dosave)
{
  struct termios t;

  /* Get the device's terminal attributes */
  if (tcgetattr(fd, &t) == -1) {
    fprintf(stderr, "Error getting %s attributes: %s\n",
						 portname, strerror(errno));
    exit(1);
  }
  if (dosave) memcpy(&oldterm,&t,sizeof(t));	/* Save the old settings */

  /* Set raw - code stolen from 4.4BSD libc/termios.c */
  t.c_iflag &= ~(IMAXBEL | IXOFF | INPCK | BRKINT | PARMRK | ISTRIP |
		 INLCR | IGNCR | ICRNL | IXON | IGNPAR);
  t.c_iflag |= IGNBRK;
  t.c_oflag &= ~OPOST;
  t.c_lflag &= ~(ECHO | ECHOE | ECHOK | ECHONL | ICANON | ISIG | IEXTEN |
		 NOFLSH | TOSTOP | PENDIN);
  t.c_cflag &= ~(CSIZE | PARENB);
  t.c_cflag |= CS8 | CREAD;
  t.c_cc[VMIN] = 1;
  t.c_cc[VTIME] = 0;

  /* Set the device's terminal attributes */
  if (tcsetattr(fd, TCSANOW, &t) == -1) {
    fprintf(stderr, "Error setting %s attributes: %s\n",
						portname, strerror(errno));
    exit(1);
  }
}

/* Reset the terminal settings and
 * exit the process
 */
void termexit(int how)
{
  tcsetattr(ttyfd, TCSANOW, &oldterm);
  exit(how);
}


/* Open the named port and set it to raw mode.
 * Someone else deals with such things as
 * baud rate, clocal and crtscts.
 */
void open_port()
{
  fprintf(stderr,"Opening port %s .... ", port); fflush(stderr);
  portfd = open(port, O_RDWR);
  if (portfd == -1) {
    fprintf(stderr, "Error opening device %s: %s\n", port, strerror(errno));
    exit(1);
  }
  fprintf(stderr,"Port open\n");
  setraw(portfd,port,0);
}

void server_loop()
{
  char ch;
  int i;
  int esc_num=0;
  int in_tape_mode=0;		/* Are we in tape mode or console mode */
  fd_set fdset;

  FD_ZERO(&fdset);
  while (1) {
    FD_SET(ttyfd, &fdset);
    FD_SET(portfd, &fdset);	/* Wait for chars in stdin or serial line */

    i=select(portfd+1, &fdset, NULL, NULL, NULL);
    if (i<1) continue;

				/* Console input */
    if (FD_ISSET(ttyfd, &fdset)) {
	read(ttyfd,&ch,1);
	if (!in_tape_mode) {
	  if (ch=='') esc_num++;	/* Exit when two ESCs consecutively */
	  else esc_num=0;
	  if (esc_num==2) termexit(0);
	  write(portfd,&ch,1);
	}
    }
				/* Get a command from the client */
    if (FD_ISSET(portfd, &fdset)) {
      if (get_command(&vtcmd)==0) { in_tape_mode=0; continue; }

      in_tape_mode=1;
      do_command();		/* Do the command */
      send_reply();		/* Send the reply */
    }
  }
}



int main(void)
{
  fprintf(stderr,"Virtual tape server, $Revision: 2.2 $ \n");

  read_config(); open_port();
  setraw(ttyfd,"standard input",1); 
  server_loop();
  exit(0);
}
@


2.3.1.1
log
@added what I think is ODT support, but no ODT simulator to try it on
@
text
@d4 2
a5 2
 * $Revision: 2.3 $
 * $Date: 2001/03/23 00:02:49 $
a127 13
/* This array holds the bootstrap code, which we can enter via ODT
 * at the BOOTSTART address.
 */
#define BOOTSTART 0140000
int bootcode[]= {
	0010706, 005003, 0012701, 0177560, 012704, 0140106, 0112400, 0100406,
	0105761, 000004, 0100375, 0110061, 000006, 0000770, 0005267, 0000052,
	0004767, 000030, 0001403, 0012703, 006400, 0005007, 0012702, 0001000,
	0004767, 000010, 0110023, 0005302, 001373, 0000746, 0105711, 0100376,
	0116100, 000002, 0000207, 0025037, 000000, 0000000, 0177777
};
int havesentbootcode=0;

d135 1
a135 1
  int i,loc;
a136 1
  char bootbuf[40];
a139 12

  /* Send down the bootstrap code to ODT if we see an @@ sign */
  if ((havesentbootcode==0) && (v->hdr1 == '@@')) {
    for (i=0,loc=BOOTSTART;i<(sizeof(bootcode)/sizeof(int));i++,loc+=2) {
	sprintf(bootbuf, "%6o/%6o\r", loc, bootcode[i]);
        write(portfd, bootbuf, strlen(bootbuf)-1);
    }
    sprintf(bootbuf, "%6oG", BOOTSTART);
    write(portfd, bootbuf, strlen(bootbuf)-1);
    havesentbootcode=1; return(0);
  }

a407 1
  ch='\r'; write(portfd,&ch,1);	/* Send a \r to wake ODT up if it is there */
d441 1
a441 1
  fprintf(stderr,"Virtual tape server, $Revision: 2.3 $ \n");
@


2.3.1.2
log
@only enable ODT dump if user wants is
@
text
@d4 2
a5 2
 * $Revision: 2.3.1.1 $
 * $Date: 2001/03/24 07:01:48 $
d139 1
a139 1
int havesentbootcode=1;		/* Don't send it unless user asks on cmd line */
d466 1
a466 1
int main(int argc, char *argv[])
d468 1
a468 1
  fprintf(stderr,"Virtual tape server, $Revision: 2.3.1.1 $ \n");
a469 1
  if (!strcmp(argv[1], "-odt")) havesentbootcode=0;
@


2.3.1.3
log
@added -odt option
@
text
@d4 2
a5 2
 * $Revision: 2.3.1.2 $
 * $Date: 2001/03/24 07:29:27 $
d306 1
d468 1
a468 1
  fprintf(stderr,"Virtual tape server, $Revision: 2.3.1.2 $ \n");
d470 1
a470 1
  if ((argc==2) && (!strcmp(argv[1], "-odt"))) havesentbootcode=0;
@


2.3.1.4
log
@modified to try opening r/w, r/o, newfile, and reporting as such
@
text
@d4 2
a5 2
 * $Revision: 2.3.1.3 $
 * $Date: 2001/03/25 01:21:27 $
d150 1
a150 1
  char ch,bootbuf[40];
a159 3

	/* and suck up any characters sent from ODT */
	while (1) { read(portfd, &ch, 1); if (ch=='@@') break; }
a162 1
    while (1) { read(portfd, &ch, 1); if (ch=='G') break; }
d260 3
a262 3
    if (i>=0) {
       fprintf(stderr,"\nOpened %s read-write\r\n ", recname[record]);
       goto afteropen;			/* yuk, a goto! */
d264 1
a264 14
    i = open(recname[record], O_RDONLY);
    if (i>=0) {
       fprintf(stderr,"\nOpened %s read-only\r\n ", recname[record]);
       goto afteropen;			/* yuk, a goto! */
    }
    i = open(recname[record], O_RDWR|O_CREAT|O_TRUNC, 0600);
    if (i>=0) {
       fprintf(stderr,"\nOpened %s as a new file\r\n ", recname[record]);
       goto afteropen;			/* yuk, a goto! */
    }
    fprintf(stderr,"Cannot open %s: %s\r\n",recname[record], strerror(errno));
    seterror(VTE_NOREC); return;
 
afteropen:
d267 1
d467 1
a467 1
  fprintf(stderr,"Virtual tape server, $Revision: 2.3.1.3 $ \n");
@


2.3.1.5
log
@added fix for ODT downloading
@
text
@d4 2
a5 2
 * $Revision: 2.3.1.4 $
 * $Date: 2001/03/25 02:11:13 $
d158 2
a159 7
	sprintf(bootbuf, "%06o/", loc);
	write(portfd, bootbuf, strlen(bootbuf));

	/* wait for current value to print */
	while (1) { read(portfd, &ch, 1); if (ch==' ') break; }
	sprintf(bootbuf, "%06o\r", bootcode[i]);
	write(portfd, bootbuf, strlen(bootbuf));
d164 2
a165 2
    sprintf(bootbuf, "%06oG", BOOTSTART);
    write(portfd, bootbuf, strlen(bootbuf));
d483 1
a483 1
  fprintf(stderr,"Virtual tape server, $Revision: 2.3.1.4 $ \n");
@


2.2
log
@added 100K write message
@
text
@d4 2
a5 2
 * $Revision: 2.1 $
 * $Date: 2001/03/02 04:40:31 $
d405 1
a405 1
  int in_tape_mode=1;		/* Are we in tape mode or console mode */
d441 1
a441 1
  fprintf(stderr,"Virtual tape server, $Revision: 2.1 $ \n");
@


2.1
log
@added write support to the server. also changed the
server so that it restores the original terminal
settings when it exits normally.
@
text
@d4 2
a5 2
 * $Revision: 2.0 $
 * $Date: 2001/01/30 03:28:14 $
d278 3
d441 1
a441 1
  fprintf(stderr,"Virtual tape server, $Revision: 2.0 $ \n");
@


2.0
log
@ok, first version which multiplexes console and serial protocol on the
one serial line
@
text
@d4 2
a5 2
 * $Revision: 1.1 $
 * $Date: 2001/01/24 02:22:10 $
d23 1
a23 1
 * low-order byte first. Any data that is transmitted (in either direction)
d29 3
a31 2
 * A write command from the client has 512 bytes of data. Similarly, a read
 * command from the server to the client has 512 bytes of data.
d36 2
a37 1
 * The protocol is stateless. Commands are read, write, open and close.
d49 2
a50 2
 * command byte hold the return error value. All bits off indicates no error.
 * If an error occurred, including EOF, no data bytes are returned on a read
d62 6
d92 1
a92 1
/* Header bytes */
d98 5
a102 6
#define VTC_OPEN	1
#define VTC_CLOSE	2
#define VTC_READ	3
#define VTC_WRITE	4
#define VTC_ACK		5
#define VTC_ZEROREAD	6
d116 1
a116 1
extern int errno;
d126 1
d130 1
a130 1
 * If a comamnd is received, returns 1,
d138 1
a138 1
/* Get a valid command from the client */
d161 1
d168 1
a168 1
    { fprintf(stderr,"e"); return(0); }
d270 7
a276 1
    case VTC_WRITE: i = write(recfd, &inbuf, BLKSIZE);
d280 1
d336 4
a339 1
void setraw(int fd, char *portname)
d349 1
d371 10
d394 1
a394 1
  setraw(portfd,port);
d419 1
a419 1
	  if (esc_num==2) exit(0);
d435 1
d438 1
a438 1
  fprintf(stderr,"Virtual tape server, $Revision: 1.1 $ \n");
d441 1
a441 1
  setraw(ttyfd,"standard input"); 
@


1.1
log
@Initial revision
@
text
@d4 2
a5 2
 * $Revision: 1.13 $
 * $Date: 1998/01/30 02:39:41 $
d68 1
d92 1
a92 1
#define VTC_READ	3	/* This server only uses READ and OPEN */
d115 3
a117 2
int recfd = 0;			/* File descriptor for the in-use record */
int lastrec = -1;		/* Last record used */
d121 5
a125 1
void get_command(struct vtcmd *v)
d130 1
a130 2
getcmd:			/* Get a valid command from the client */
  /* printf("Waiting 1st char in cmd\n"); */
d132 1
a132 2
  /* printf("Just got hdr1 0x%x\n", v->hdr1); */
  if (v->hdr1 != VT_HDR1) goto getcmd;
d134 1
a134 2
  /* printf("Just got hdr2 0x%x\n", v->hdr2); */
  if (v->hdr2 != VT_HDR2) goto getcmd;
a137 4
  /* printf("Just got cmd 0x%x\n", v->cmd); */
  /* printf("Just got record 0x%x\n", v->record); */
  /* printf("Just got blklo 0x%x\n", v->blklo); */
  /* printf("Just got blkhi 0x%x\n", v->blkhi); */
d144 1
a144 1
  if (v->cmd == VTC_QUICK) return;
a154 1
  /* printf("Just got sum0 0x%x\n", v->sum0); */
a155 1
  /* printf("Just got sum1 0x%x\n", v->sum1); */
d159 1
a159 1
    { putchar('e'); goto getcmd; }
d161 1
a161 1
  /* printf("Yay, a valid command!\n"); */
d169 7
a175 3
#ifdef DELAY
  int j;
#endif
a195 2
  /* printf("Sent reply: command\n"); */

d197 1
a197 9
    for (i = 0; i < BLKSIZE; i++) {
      write(portfd, &inbuf[i], 1);

#ifdef DELAY
      for (j = 0; j < 5120; j++) { ; }	/* Slight delay, why is this needed? */
#endif

    }
    /* printf("Sent reply: data\n"); */
a198 1

a200 3

  /* printf("Sent reply: checksum\n"); */

a203 1

d220 1
a220 1
	printf("No such tape record %d\n",record);
d226 2
a227 2
	printf("Cannot open %s: %s\n",recname[record], strerror(errno));
        seterror(VTE_NOREC); return;
d232 1
a232 1
    printf("\nOpened %s\n", recname[record]);
d237 1
a237 1
    case VTC_CLOSE: putchar('c'); close(recfd); lastrec = -1; break;
d239 1
d241 1
d244 1
a244 1
      		    	{ printf(" EOF\n"); seterror(VTE_EOF); return; }
d247 1
a247 1
      		        { printf(" EOF\n"); seterror(VTE_EOF); return; }
d250 5
a254 6
			/* Determine if the entire block is zero */
		    for (i=0;i<BLKSIZE;i++) if (inbuf[i]!=0) break;
		    if (i==BLKSIZE) {
			vtreply.cmd=VTC_ZEROREAD; putchar('z');
		    } else {
			vtreply.cmd=VTC_READ; putchar('r');
d258 2
a259 1
			printf("\n%dK sent\n", offset/1024);
d261 1
a261 16
    case VTC_QUICK: putchar('q'); vtreply.cmd=0;	/* No errors yet */
			goto x;
    case VTC_READ:  putchar('r');
x:
			/* printf("lseek to %d\n",offset); */
		    i= lseek(recfd, offset, SEEK_SET);
      		    if (i==-1)
      		    	{ printf(" EOF\n"); seterror(VTE_EOF); return; }
   		    i = read(recfd, &inbuf, BLKSIZE);
      		    if (i == 0)
      		        { printf(" EOF\n"); seterror(VTE_EOF); return; }
      		    if (i == -1) { seterror(VTE_READ); return; }
		    if (offset && (offset % 102400) == 0)
			printf("\n%dK sent\n", offset/1024);
      		    break;
    case VTC_WRITE: putchar('w'); i = write(recfd, &inbuf, BLKSIZE);
d263 1
d265 2
a266 3
    default:	    putchar('?');
		    /* printf("Got unknown command %d\n", vtcmd.cmd); */
   		    seterror(VTE_NOCMD); return;
d268 1
a268 1
  fflush(stdout);
d301 1
a301 1
	printf("Running command %s\n\n",inbuf);
d313 3
a315 3
  printf("Tape records are:\n");
  for (i=0; i<cnt; i++) printf("  %2d %s\n", i, recname[i]);
  printf("\n");
d320 1
a320 5
/* Open the named port and set it to raw mode.
 * Someone else deals with such things as
 * baud rate, clocal and crtscts.
 */
void open_port()
a323 8
  printf("Opening port %s .... ", port); fflush(stdout);
  portfd = open(port, O_RDWR);
  if (portfd == -1) {
    fprintf(stderr, "Error opening device %s: %s\n", port, strerror(errno));
    exit(1);
  }
  printf("Port open\n");

d325 3
a327 2
  if (tcgetattr(portfd, &t) == -1) {
    fprintf(stderr, "Error getting %s attributes: %s\n", port, strerror(errno));
d344 3
a346 2
  if (tcsetattr(portfd, TCSANOW, &t) == -1) {
    fprintf(stderr, "Error setting %s attributes: %s\n", port, strerror(errno));
d351 15
d369 1
d371 3
d375 1
d377 2
a378 2
    /* printf("Getting a command: "); */
    get_command(&vtcmd);	/* Get a command from the client */
d380 2
a381 1
    do_command();		/* Do the command */
d383 17
a399 7
    if (vtcmd.cmd==VTC_QUICK) {	/* Only send buffer on a quick read */
	write(portfd, &vtreply.cmd, 1);
	/* printf("Just sent quick byte 0%o\n", vtreply.cmd); */
	for (i=0; i< BLKSIZE; i++) {
	  write(portfd, &inbuf[i], 1);
 	}
	fflush(stdout); continue;
a400 3

    send_reply();		/* Send the reply */

d407 1
a407 5
  printf("Virtual tape server, $Revision: 1.13 $ \n");

  read_config();

  open_port();
d409 2
@
